# Copyright 2014 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

"""deferred_resource converts blocking apiclient resource to deferred."""

import functools
import httplib
import time
import threading
import traceback

from common.chromium_utils import AddThirdPartyLibToPath
from twisted.internet import defer, reactor
from twisted.python import log as twistedLog
from twisted.python.threadpool import ThreadPool

AddThirdPartyLibToPath('google_api_python_client')
AddThirdPartyLibToPath('httplib2/python2')
AddThirdPartyLibToPath('oauth2client')
AddThirdPartyLibToPath('uritemplate')

import apiclient
import httplib2


DEFAULT_RETRY_ATTEMPT_COUNT = 5
DEFAULT_RETRY_WAIT_SECONDS = 1


class DeferredResource(object):
  """Wraps an apiclient Resource, converts its methods to deferred.

  Accepts an apiclient.Resource, such as one generated by
  apiclient.discovery.build, and wraps all resource methods. When deferrred
  resource method is called, it schedules an actual rpc in a twisted thread pool
  and returns a Deferred.

  Has to be explicitly started and stopped. This can be done using "with"
  statement, see examples.

  Examples:
    Basic usage:

      @defer.inlineCallbacks
      def greet():
        # Asynchronously build a DeferredResource for my_greeting_service API.
        service = yield DeferredResource.build('my_greeting_service', 'v1')
        with service:
          response = yield res.api.greet('John')
          defer.returnValue(response)

    Authorization:

     def create_http():
       with open(secret_key_filename, 'rb') as f:
         secret_key = f.read()
       AUTH_SCOPE = 'https://www.googleapis.com/auth/userinfo.email'
       creds = SignedJwtAssertionCredentials(service_account, secret_key,
            AUTH_SCOPE)
       return creds.authorize(httplib2.Http())

      service = yield DeferredResource.build('my_greeting_service', 'v1',
                                             http_factory=create_http)

  Also DeferredResource retries requests on transient errors with exponential
  backoff and refreshes access token on FORBIDDEN response statuses.
  """

  class Api(object):
    """Dynamically creates resource methods."""
    def __init__(self, owner):
      self._methods = {}
      self._owner = owner

    def __getattr__(self, name):
      method = self._methods.get(name)
      if method is None:
        method = self._owner._twistify(name)
        if method is None:
          raise AttributeError('Resource does not have method %s' % name)
        self._methods[name] = method
      return method

  def __init__(self, resource, http_factory=None, retry_wait_seconds=None,
               retry_attempt_count=None, verbose=False, log_prefix='',
               _pool=None):
    """Creates a DeferredResource.

    Args:
      resource (apiclient.Resource): a resource, such as one generated by
        apiclient.discovery.build.
      http_factory (function): creates httplib2.Http to use for RPC. Will be
        called from different threads. If the resource starts to respond with
        httplib.FORBIDDEN statuses, which may imply that an access token
        expired, the http is recreated. Defaults to httplib2.Http.
      retry_wait_seconds (int, float): initial wait interval for request
        retrial. In seconds, defaults to 1.
      retry_attempt_count (int): number of attempts before giving up.
        Defaults to 5.
      verbose (bool): if True, log each request/response.
      log_prefix (str): prefix for log messages.
    """
    assert resource, 'resource not specified'
    http_factory = http_factory or httplib2.Http
    assert hasattr(http_factory, '__call__'), ('http_factory must be a '
                                               'function')
    if retry_wait_seconds is None:
      retry_wait_seconds = DEFAULT_RETRY_WAIT_SECONDS
    assert isinstance(retry_wait_seconds, (int, float))
    if retry_attempt_count is None:
      retry_attempt_count = DEFAULT_RETRY_ATTEMPT_COUNT
    assert isinstance(retry_attempt_count, int)

    self._pool = _pool or self._create_thread_pool()
    self._resource = resource
    self._http_factory = http_factory
    self.retry_wait_seconds = retry_wait_seconds
    self.retry_attempt_count = retry_attempt_count
    self.verbose = verbose
    self.log_prefix = log_prefix
    self.api = self.Api(self)
    self._th_local = threading.local()

  @classmethod
  def _create_thread_pool(cls):
    return ThreadPool(minthreads=1, maxthreads=1)

  @classmethod
  def _create_async(cls, resource_factory, _pool=None, **kwargs):
    _pool = _pool or cls._create_thread_pool()
    result = defer.Deferred()

    def create_sync():
      # Stop the thread pool after creating DeferredResource.
      reactor.callFromThread(_pool.stop)
      try:
        assert resource_factory, 'resource_factory is not specified'
        res = resource_factory()
        def_res = cls(res, _pool=_pool, **kwargs)
        reactor.callFromThread(result.callback, def_res)
      except Exception as ex:
        reactor.callFromThread(result.errback, ex)

    _pool.start()
    _pool.callInThread(create_sync)
    return result

  # Yes, I've copied all these parameters because being explicit is good.
  @classmethod
  def build(cls, service_name, version, http_factory=None,
            discoveryServiceUrl=apiclient.discovery.DISCOVERY_URI,
            developerKey=None, model=None,
            requestBuilder=apiclient.http.HttpRequest,
            retry_wait_seconds=None, retry_attempt_count=None, verbose=False,
            log_prefix=''):
    """Asynchronously builds a DeferredResource for a discoverable API.

    Asynchronously builds a resource by calling apiclient.discovery.build and
    wraps it with a DeferredResource.

    Args:
      serviceName: string, name of the service.
      version: string, the version of the service.
      http_factory (function): creates httplib2.Http to use for RPC. Will be
        called from different threads. If the resource starts to respond with
        httplib.FORBIDDEN statuses, which may imply that an access token
        expired, the http is recreated. Defaults to httplib2.Http.
      discoveryServiceUrl: string, a URI Template that points to the location of
        the discovery service. It should have two parameters {api} and
        {apiVersion} that when filled in produce an absolute URI to the
        discovery document for that service.
      developerKey: string, key obtained from
        https://code.google.com/apis/console.
      model: apiclient.Model, converts to and from the wire format.
      requestBuilder: apiclient.http.HttpRequest, encapsulator for an HTTP
        request.
      retry_wait_seconds (int, float): initial wait interval for request
        retrial. In seconds, defaults to 1.
      retry_attempt_count (int): number of attempts before giving up.
        Defaults to 5.
      verbose (bool): if True, log each request/response.
      log_prefix (str): prefix for log messages.

    Returns:
      A DeferredResource as Deferred.
    """
    # Do not check arguments synchronously. Let the client check for exceptions
    # only in errback.
    def resource_factory():
      return apiclient.discovery.build(
          service_name,
          version,
          discoveryServiceUrl=discoveryServiceUrl,
          developerKey=developerKey,
          requestBuilder=requestBuilder,
      )

    return cls._create_async(resource_factory,
                             http_factory=http_factory,
                             retry_wait_seconds=retry_wait_seconds,
                             retry_attempt_count=retry_attempt_count,
                             verbose=verbose,
                             log_prefix=log_prefix,
    )

  def log(self, message):
    twistedLog.msg('%s%s' % (self.log_prefix, message))

  def start(self):
    self._pool.start()

  def stop(self):
    self._pool.stop()

  def __enter__(self):
    self.start()
    return self

  def __exit__(self, *args, **kwrags):
    self.stop()

  def create_http(self):
    try:
      http = self._http_factory()
      assert isinstance(http, httplib2.Http), ('http_factory returned '
                                               'non-httplib2.Http')
      return http
    except:
      self.log('Could not create http: %s' % traceback.format_exc())
      raise

  @property
  def refresh_http_on_forbidden(self):
    return self._http_factory is not httplib2.Http

  def _retry(self, method_name, call):
    """Retries |call| on transient errors and access token expiration.

    Args:
      method_name (str): name of the remote method, for logging.
      call (func(httplib2.Http) -> any): a function that accepts
        httplib2.Http and returns an RPC result.
    """
    if not hasattr(self._th_local, 'http') or self._th_local.http is None:
      self._th_local.http = self.create_http()

    attempts = self.retry_attempt_count
    wait = self.retry_wait_seconds
    just_refreshed_token = False
    while attempts > 0:
      attempts -= 1
      try:
        return call(self._th_local.http)
      except apiclient.errors.HttpError as ex:
        status = ex.resp.status if ex.resp else None
        if (status == httplib.FORBIDDEN and self.refresh_http_on_forbidden and
            not just_refreshed_token):
          # Assume access token expired.
          self._th_local.http = self.create_http()
          just_refreshed_token = True
        elif status >= 500:
          self.log('Transient error while calling %s. '
                   'Will retry in %d seconds.' % (method_name, wait))
          # TODO(nodir), optimize: stop waiting if the resource is stopped.
          time.sleep(wait)
          wait *= 2
        else:
          self.log('RPC "%s" failed: %s'
                   % (method_name, traceback.format_exc()))
          raise

  def _log_request(self, method_name, args, kwargs):
    arg_str_list = map(repr, args)
    arg_str_list += ['%s=%r' % (k, v) for k, v in kwargs.iteritems()]
    self.log('Request %s(%s)' % (method_name, ', '.join(arg_str_list)))

  def _twistify(self, method_name):
    """Wraps a resource method by name."""
    method = getattr(self._resource, method_name, None)
    if method is None:
      return None

    @functools.wraps(method)
    def twistified(*args, **kwargs):
      result = defer.Deferred()

      def single_call(http):
        """Makes one RPC. Used as |call| parameters in _retry func."""
        if self.verbose:
          self._log_request(method_name, args, kwargs)
        response = method(*args, **kwargs).execute(http)
        if self.verbose:
          self.log('Reponse: %s' % response)
        return response

      def execute():
        try:
          response = self._retry(method_name, single_call)
          reactor.callFromThread(result.callback, response)
        except Exception as ex:
          reactor.callFromThread(result.errback, ex)

      self._pool.callInThread(execute)
      return result

    return twistified
